# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input AssignRoleInput {
  roleId: Int!
  userId: Int!
}

type AuthResponse {
  accessToken: String!
  user: User!
}

input BooleanFieldComparison {
  is: Boolean
  isNot: Boolean
}

type Category {
  color: String
  companies: [Company!]
  createdAt: DateTime!
  deletedAt: DateTime
  description: String!
  icon: String
  id: ID!
  isActive: Boolean!
  keywords: String
  name: String!
  order: Float!
  place: Place!
  placeId: Float!
  segments: [Segment!]
  slug: String!
  subcategories: [Subcategory!]
  updatedAt: DateTime!
  uuid: String!
}

type Company {
  address: String
  banner: String
  basicInfo: CompanyBasicInfo
  category: Category!
  categoryId: Float!
  cnpj: String
  createdAt: DateTime!
  deletedAt: DateTime
  delivery: CompanyDelivery
  deliveryZones: [DeliveryZone!]
  description: String!
  email: String
  id: ID!
  isActive: Boolean!
  latitude: Float
  logo: String
  longitude: Float
  name: String!
  openingHours: String
  payments: CompanyPayments
  phone: String
  place: Place!
  placeId: Float!
  schedule: CompanySchedule
  scheduleHours: [CompanyScheduleHour!]
  segment: Segment!
  segmentId: Float!
  slug: String!
  socialNetworks: [CompanySocial!]
  socials: CompanySocials
  subcategory: Subcategory!
  subcategoryId: Float!
  tags: String
  updatedAt: DateTime!
  users: [User!]
  uuid: String!
  website: String
}

type CompanyAuthResponse {
  accessToken: String!
  company: Company!
  user: User!
}

type CompanyBasicInfo {
  address: String
  banner: String
  company: Company!
  companyId: Float!
  createdAt: DateTime!
  deletedAt: DateTime
  description: String
  email: String
  id: ID!
  isActive: Boolean!
  logo: String
  phone: String
  updatedAt: DateTime!
  uuid: String!
  whatsapp: String
}

type CompanyDelivery {
  acceptsCard: Boolean!
  acceptsCash: Boolean!
  acceptsPix: Boolean!
  availableTypes: [DeliveryType!]!
  baseFee: Float!
  company: Company!
  companyId: Float!
  createdAt: DateTime!
  deletedAt: DateTime
  deliveryInstructions: String
  deliveryPhone: String
  deliveryWhatsApp: String
  deliveryZones: [DeliveryZone!]
  estimatedTimeMinutes: Float!
  freeDeliveryMinValue: Float
  id: ID!
  isActive: Boolean!
  isEnabled: Boolean!
  maximumOrderValue: Float
  minimumOrderValue: Float
  pickupInstructions: String
  pickupTimeMinutes: Float!
  updatedAt: DateTime!
  uuid: String!
}

input CompanyLoginInput {
  companySlug: String!
  email: String!
  password: String!
}

type CompanyPayments {
  acceptsInstallments: Boolean!
  cardInfo: String
  company: Company!
  companyId: Float!
  createdAt: DateTime!
  deletedAt: DateTime
  id: ID!
  isActive: Boolean!
  maxInstallments: Float
  minimumCardAmount: Float
  notes: String
  paymentMethods: [PaymentMethodType!]!
  pixDescription: String
  pixKey: String
  pixKeyType: PixKeyType
  updatedAt: DateTime!
  uuid: String!
  voucherInfo: String
}

type CompanySchedule {
  advanceBookingDays: Float
  allowOnlineScheduling: Boolean!
  autoUpdateStatus: Boolean!
  closedMessage: String
  company: Company!
  companyId: Float!
  createdAt: DateTime!
  deletedAt: DateTime
  hasDeliverySchedule: Boolean!
  hasTakeoutSchedule: Boolean!
  holidayMessage: String
  id: ID!
  isActive: Boolean!
  isEnabled: Boolean!
  scheduleHours: [CompanyScheduleHour!]
  scheduleNotes: String
  showNextOpenTime: Boolean!
  slotDurationMinutes: Float
  timezone: String
  updatedAt: DateTime!
  uuid: String!
}

type CompanyScheduleHour {
  breakEndTime: String
  breakStartTime: String
  closeTime: String
  company: Company!
  companyId: Float!
  createdAt: DateTime!
  dayOfWeek: DayOfWeek!
  deletedAt: DateTime
  id: ID!
  is24Hours: Boolean!
  isActive: Boolean!
  isClosed: Boolean!
  notes: String
  openTime: String
  priority: Float!
  scheduleType: ScheduleType!
  specificDate: DateTime
  updatedAt: DateTime!
  uuid: String!
  validFrom: DateTime
  validUntil: DateTime
}

type CompanySocial {
  company: Company!
  companyId: Float!
  createdAt: DateTime!
  deletedAt: DateTime
  description: String
  displayName: String
  displayOrder: Float!
  followersCount: Float
  id: ID!
  isActive: Boolean!
  isPrimary: Boolean!
  isVisible: Boolean!
  lastUpdated: DateTime
  networkType: SocialNetworkType!
  updatedAt: DateTime!
  url: String!
  username: String
  uuid: String!
}

type CompanySocials {
  allowMessages: Boolean!
  company: Company!
  companyId: Float!
  createdAt: DateTime!
  deletedAt: DateTime
  id: ID!
  isActive: Boolean!
  isEnabled: Boolean!
  primaryContactSocial: String
  showFollowersCount: Boolean!
  socialMediaRules: String
  socialMediaStrategy: String
  socialNetworks: [CompanySocial!]
  updatedAt: DateTime!
  uuid: String!
}

"""Cursor for paging through collections"""
scalar ConnectionCursor

input CreateCategoryInput {
  color: String
  description: String!
  icon: String
  isActive: Boolean
  keywords: String
  name: String!
  order: Float
  placeId: Int!
  segmentIds: [Int!]
  slug: String!
}

input CreateCompanyBasicInfoInput {
  address: String
  banner: String
  description: String
  email: String
  logo: String
  phone: String
  whatsapp: String
}

input CreateCompanyDeliveryInput {
  acceptsCard: Boolean
  acceptsCash: Boolean
  acceptsPix: Boolean
  availableTypes: [DeliveryType!]
  baseFee: Float
  deliveryInstructions: String
  deliveryPhone: String
  deliveryWhatsApp: String
  deliveryZones: [CreateDeliveryZoneInput!]
  estimatedTimeMinutes: Int
  freeDeliveryMinValue: Float
  isEnabled: Boolean
  maximumOrderValue: Float
  minimumOrderValue: Float
  pickupInstructions: String
  pickupTimeMinutes: Int
}

input CreateCompanyInput {
  address: String
  banner: String
  categoryId: Int!
  cnpj: String
  description: String!
  email: String
  isActive: Boolean
  latitude: Float
  logo: String
  longitude: Float
  name: String!
  openingHours: String
  phone: String
  placeId: Int!
  segmentId: Int!
  slug: String!
  subcategoryId: Int!
  users: [CreateCompanyUserInput!]
  website: String
}

input CreateCompanyPaymentsInput {
  acceptsInstallments: Boolean
  cardInfo: String
  maxInstallments: Int
  minimumCardAmount: Float
  notes: String
  paymentMethods: [PaymentMethodType!]!
  pixDescription: String
  pixKey: String
  pixKeyType: PixKeyType
  voucherInfo: String
}

input CreateCompanyScheduleInput {
  advanceBookingDays: Int
  allowOnlineScheduling: Boolean
  autoUpdateStatus: Boolean
  closedMessage: String
  hasDeliverySchedule: Boolean
  hasTakeoutSchedule: Boolean
  holidayMessage: String
  isEnabled: Boolean
  scheduleHours: [CreateScheduleHourInput!]
  scheduleNotes: String
  showNextOpenTime: Boolean
  slotDurationMinutes: Int
  timezone: String
}

input CreateCompanySocialInput {
  description: String
  displayName: String
  displayOrder: Int
  followersCount: Int
  isPrimary: Boolean
  isVisible: Boolean
  networkType: SocialNetworkType!
  url: String!
  username: String
}

input CreateCompanySocialsInput {
  allowMessages: Boolean
  isEnabled: Boolean
  primaryContactSocial: String
  showFollowersCount: Boolean
  socialMediaRules: String
  socialMediaStrategy: String
  socialNetworks: [CreateCompanySocialInput!]
}

input CreateCompanyUserInput {
  email: String
  existingUserId: Float
  isActive: Boolean
  name: String
  password: String
  phone: String
  role: String
}

input CreateDeliveryZoneInput {
  deliveryFee: Float!
  description: String
  estimatedTimeMinutes: Int!
  isEnabled: Boolean
  minimumOrderValue: Float
  name: String!
  neighborhoods: String!
  priority: Int
}

input CreateManyOrganizationsInput {
  """Array of records to create"""
  organizations: [CreateOrganizationInput!]!
}

input CreateOneOrganizationInput {
  """The record to create"""
  organization: CreateOrganizationInput!
}

input CreateOrganizationInput {
  banner: String
  description: String!
  isActive: Boolean
  logo: String
  name: String!
  slug: String!
}

input CreatePlaceInput {
  banner: String
  city: String!
  description: String!
  isActive: Boolean
  latitude: Float
  logo: String
  longitude: Float
  name: String!
  neighborhood: String
  postalCode: String
  slug: String!
  state: String!
}

input CreateScheduleHourInput {
  breakEndTime: String
  breakStartTime: String
  closeTime: String
  dayOfWeek: DayOfWeek!
  is24Hours: Boolean
  isClosed: Boolean
  notes: String
  openTime: String
  priority: Int
  scheduleType: ScheduleType
  specificDate: String
  validFrom: String
  validUntil: String
}

input CreateSegmentInput {
  categoryIds: [Int!]
  color: String
  description: String!
  icon: String
  isActive: Boolean
  name: String!
  order: Float
  placeId: Int!
  slug: String!
}

input CreateSubcategoryInput {
  categoryId: Int!
  description: String!
  icon: String
  isActive: Boolean
  keywords: String
  name: String!
  order: Float
  placeId: Int!
  slug: String!
}

input CreateUserInput {
  avatar: String
  companyId: Int
  email: String!
  isActive: Boolean
  name: String!
  organizationId: Int
  password: String!
  phone: String
  placeId: Int
  roleIds: [Int!]
}

input CursorPaging {
  """Paginate after opaque cursor"""
  after: ConnectionCursor

  """Paginate before opaque cursor"""
  before: ConnectionCursor

  """Paginate first"""
  first: Int

  """Paginate last"""
  last: Int
}

input DateFieldComparison {
  between: DateFieldComparisonBetween
  eq: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  is: Boolean
  isNot: Boolean
  lt: DateTime
  lte: DateTime
  neq: DateTime
  notBetween: DateFieldComparisonBetween
  notIn: [DateTime!]
}

input DateFieldComparisonBetween {
  lower: DateTime!
  upper: DateTime!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""Dias da semana"""
enum DayOfWeek {
  """Domingo"""
  DOMINGO

  """Quarta-feira"""
  QUARTA

  """Quinta-feira"""
  QUINTA

  """Sábado"""
  SABADO

  """Segunda-feira"""
  SEGUNDA

  """Sexta-feira"""
  SEXTA

  """Terça-feira"""
  TERCA
}

input DeleteManyOrganizationsInput {
  """Filter to find records to delete"""
  filter: OrganizationDeleteFilter!
}

type DeleteManyResponse {
  """The number of records deleted."""
  deletedCount: Int!
}

input DeleteOneOrganizationInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneUserInput {
  """The id of the record to delete."""
  id: ID!
}

"""Tipos de serviço de entrega"""
enum DeliveryType {
  """Entrega a domicílio"""
  DELIVERY

  """Consumo no local"""
  DINE_IN

  """Retirada no local"""
  PICKUP
}

type DeliveryZone {
  company: Company!
  companyId: Float!
  createdAt: DateTime!
  deletedAt: DateTime
  deliveryFee: Float!
  description: String
  estimatedTimeMinutes: Float!
  id: ID!
  isActive: Boolean!
  isEnabled: Boolean!
  minimumOrderValue: Float
  name: String!
  neighborhoods: String!
  priority: Float!
  updatedAt: DateTime!
  uuid: String!
}

input IDFilterComparison {
  eq: ID
  gt: ID
  gte: ID
  iLike: ID
  in: [ID!]
  is: Boolean
  isNot: Boolean
  like: ID
  lt: ID
  lte: ID
  neq: ID
  notILike: ID
  notIn: [ID!]
  notLike: ID
}

input LoginInput {
  email: String!
  password: String!
}

type Mutation {
  addCategoriesToSegment(categoryIds: [Int!]!, segmentId: Int!): Segment!
  addDeliveryZone(companyId: Int!, zoneData: CreateDeliveryZoneInput!): DeliveryZone!
  addScheduleHour(companyId: Int!, hourData: CreateScheduleHourInput!): CompanyScheduleHour!
  addSegmentsToCategory(categoryId: Int!, segmentIds: [Int!]!): Category!
  addSocialNetwork(companyId: Int!, socialData: CreateCompanySocialInput!): CompanySocial!
  assignCompanyAdmin(companyId: Int!, userId: Int!): Company!
  assignRole(assignRoleInput: AssignRoleInput!): UserRole!
  companyLogin(companyLoginInput: CompanyLoginInput!): CompanyAuthResponse!
  createCategory(createCategoryInput: CreateCategoryInput!): Category!
  createCompany(createCompanyInput: CreateCompanyInput!): Company!
  createCompanyBasicInfo(companyId: Int!, createBasicInfoInput: CreateCompanyBasicInfoInput!): CompanyBasicInfo!
  createCompanyDelivery(companyId: Int!, createDeliveryInput: CreateCompanyDeliveryInput!): CompanyDelivery!
  createCompanyPayments(companyId: Int!, createPaymentsInput: CreateCompanyPaymentsInput!): CompanyPayments!
  createCompanySchedule(companyId: Int!, createScheduleInput: CreateCompanyScheduleInput!): CompanySchedule!
  createCompanySocials(companyId: Int!, createSocialsInput: CreateCompanySocialsInput!): CompanySocials!
  createCompanyWithUsers(createCompanyInput: CreateCompanyInput!): Company!
  createManyOrganizations(input: CreateManyOrganizationsInput!): [Organization!]!
  createOneOrganization(input: CreateOneOrganizationInput!): Organization!
  createPlace(createPlaceInput: CreatePlaceInput!): Place!
  createSegment(createSegmentInput: CreateSegmentInput!): Segment!
  createSubcategory(createSubcategoryInput: CreateSubcategoryInput!): Subcategory!
  createUser(createUserInput: CreateUserInput!): User!
  deleteManyOrganizations(input: DeleteManyOrganizationsInput!): DeleteManyResponse!
  deleteOneOrganization(input: DeleteOneOrganizationInput!): OrganizationDeleteResponse!
  deleteOneUser(input: DeleteOneUserInput!): UserDeleteResponse!
  login(loginInput: LoginInput!): AuthResponse!
  removeCategoriesFromSegment(categoryIds: [Int!]!, segmentId: Int!): Segment!
  removeCategory(id: Int!): Category!
  removeCompany(id: Int!): Boolean!
  removeCompanyAdmin(companyId: Int!, userId: Int!): Company!
  removeCompanyBasicInfo(id: Int!): Boolean!
  removeCompanyDelivery(id: Int!): Boolean!
  removeCompanyPayments(id: Int!): Boolean!
  removeCompanySchedule(id: Int!): Boolean!
  removeCompanySocials(id: Int!): Boolean!
  removeDeliveryZone(id: Int!): Boolean!
  removePlace(id: Int!): Place!
  removeRole(roleId: Float!, userId: Float!): Boolean!
  removeScheduleHour(id: Int!): Boolean!
  removeSegment(id: Int!): Segment!
  removeSegmentsFromCategory(categoryId: Int!, segmentIds: [Int!]!): Category!
  removeSocialNetwork(id: Int!): Boolean!
  removeSubcategory(id: Int!): Subcategory!
  removeUser(id: Int!): User!
  requestPasswordReset(requestPasswordResetInput: RequestPasswordResetInput!): RequestPasswordResetResponse!
  resendVerificationEmail(resendVerificationInput: ResendVerificationInput!): VerifyEmailResponse!
  resetPassword(resetPasswordInput: ResetPasswordInput!): ResetPasswordResponse!
  signUp(signUpInput: SignUpInput!): SignUpResponse!
  testAuth: String!
  updateCategory(updateCategoryInput: UpdateCategoryInput!): Category!
  updateCompany(updateCompanyInput: UpdateCompanyInput!): Company!
  updateCompanyBasicInfo(updateBasicInfoInput: UpdateCompanyBasicInfoInput!): CompanyBasicInfo!
  updateCompanyDelivery(updateDeliveryInput: UpdateCompanyDeliveryInput!): CompanyDelivery!
  updateCompanyPayments(updatePaymentsInput: UpdateCompanyPaymentsInput!): CompanyPayments!
  updateCompanySchedule(updateScheduleInput: UpdateCompanyScheduleInput!): CompanySchedule!
  updateCompanySocials(updateSocialsInput: UpdateCompanySocialsInput!): CompanySocials!
  updateDeliveryZone(updateZoneInput: UpdateDeliveryZoneInput!): DeliveryZone!
  updateMainOrganization(updateMainOrganizationInput: UpdateMainOrganizationInput!): Organization!
  updateManyOrganizations(input: UpdateManyOrganizationsInput!): UpdateManyResponse!
  updateOneOrganization(input: UpdateOneOrganizationInput!): Organization!
  updatePlace(updatePlaceInput: UpdatePlaceInput!): Place!
  updateScheduleHour(updateHourInput: UpdateScheduleHourInput!): CompanyScheduleHour!
  updateSegment(updateSegmentInput: UpdateSegmentInput!): Segment!
  updateSocialMetrics(followersCount: Int!, id: Int!): CompanySocial!
  updateSocialNetwork(updateSocialInput: UpdateCompanySocialInput!): CompanySocial!
  updateSubcategory(updateSubcategoryInput: UpdateSubcategoryInput!): Subcategory!
  updateUser(updateUserInput: UpdateUserInput!): User!
  upsertCompanyBasicInfo(basicInfoData: CreateCompanyBasicInfoInput!, companyId: Int!): CompanyBasicInfo!
  upsertCompanyDelivery(companyId: Int!, deliveryData: CreateCompanyDeliveryInput!): CompanyDelivery!
  upsertCompanyPayments(companyId: Int!, paymentsData: CreateCompanyPaymentsInput!): CompanyPayments!
  upsertCompanySchedule(companyId: Int!, scheduleData: CreateCompanyScheduleInput!): CompanySchedule!
  upsertCompanySocials(companyId: Int!, socialsData: CreateCompanySocialsInput!): CompanySocials!
  verifyEmail(verifyEmailInput: VerifyEmailInput!): VerifyEmailResponse!
}

input NumberFieldComparison {
  between: NumberFieldComparisonBetween
  eq: Float
  gt: Float
  gte: Float
  in: [Float!]
  is: Boolean
  isNot: Boolean
  lt: Float
  lte: Float
  neq: Float
  notBetween: NumberFieldComparisonBetween
  notIn: [Float!]
}

input NumberFieldComparisonBetween {
  lower: Float!
  upper: Float!
}

type Organization {
  banner: String
  createdAt: DateTime!
  deletedAt: DateTime
  description: String!
  id: ID!
  isActive: Boolean!
  logo: String
  name: String!
  places: [Place!]
  slug: String!
  updatedAt: DateTime!
  users: [User!]
  uuid: String!
}

input OrganizationAggregateFilter {
  and: [OrganizationAggregateFilter!]
  banner: StringFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  description: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  logo: StringFieldComparison
  name: StringFieldComparison
  or: [OrganizationAggregateFilter!]
  slug: StringFieldComparison
  updatedAt: DateFieldComparison
  uuid: StringFieldComparison
}

type OrganizationAggregateGroupBy {
  banner: String
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: ID
  isActive: Boolean
  logo: String
  name: String
  slug: String
  updatedAt: DateTime
  uuid: String
}

type OrganizationAggregateResponse {
  avg: OrganizationAvgAggregate
  count: OrganizationCountAggregate
  groupBy: OrganizationAggregateGroupBy
  max: OrganizationMaxAggregate
  min: OrganizationMinAggregate
  sum: OrganizationSumAggregate
}

type OrganizationAvgAggregate {
  id: Float
}

type OrganizationConnection {
  """Array of edges."""
  edges: [OrganizationEdge!]!

  """Paging information"""
  pageInfo: PageInfo!
}

type OrganizationCountAggregate {
  banner: Int
  createdAt: Int
  deletedAt: Int
  description: Int
  id: Int
  isActive: Int
  logo: Int
  name: Int
  slug: Int
  updatedAt: Int
  uuid: Int
}

input OrganizationDeleteFilter {
  and: [OrganizationDeleteFilter!]
  banner: StringFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  description: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  logo: StringFieldComparison
  name: StringFieldComparison
  or: [OrganizationDeleteFilter!]
  slug: StringFieldComparison
  updatedAt: DateFieldComparison
  uuid: StringFieldComparison
}

type OrganizationDeleteResponse {
  banner: String
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: ID
  isActive: Boolean
  logo: String
  name: String
  places: [Place!]
  slug: String
  updatedAt: DateTime
  users: [User!]
  uuid: String
}

type OrganizationEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the Organization"""
  node: Organization!
}

input OrganizationFilter {
  and: [OrganizationFilter!]
  banner: StringFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  description: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  logo: StringFieldComparison
  name: StringFieldComparison
  or: [OrganizationFilter!]
  slug: StringFieldComparison
  updatedAt: DateFieldComparison
  uuid: StringFieldComparison
}

type OrganizationMaxAggregate {
  banner: String
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: ID
  logo: String
  name: String
  slug: String
  updatedAt: DateTime
  uuid: String
}

type OrganizationMinAggregate {
  banner: String
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: ID
  logo: String
  name: String
  slug: String
  updatedAt: DateTime
  uuid: String
}

input OrganizationSort {
  direction: SortDirection!
  field: OrganizationSortFields!
  nulls: SortNulls
}

enum OrganizationSortFields {
  banner
  createdAt
  deletedAt
  description
  id
  isActive
  logo
  name
  slug
  updatedAt
  uuid
}

type OrganizationSumAggregate {
  id: Float
}

input OrganizationUpdateFilter {
  and: [OrganizationUpdateFilter!]
  banner: StringFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  description: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  logo: StringFieldComparison
  name: StringFieldComparison
  or: [OrganizationUpdateFilter!]
  slug: StringFieldComparison
  updatedAt: DateFieldComparison
  uuid: StringFieldComparison
}

type PageInfo {
  """The cursor of the last returned record."""
  endCursor: ConnectionCursor

  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean

  """The cursor of the first returned record."""
  startCursor: ConnectionCursor
}

"""Tipos de métodos de pagamento aceitos pela empresa"""
enum PaymentMethodType {
  """Boleto Bancário"""
  BOLETO

  """Cartão de Crédito"""
  CARTAO_CREDITO

  """Cartão de Débito"""
  CARTAO_DEBITO

  """Dinheiro"""
  DINHEIRO

  """Pagamento via PIX"""
  PIX

  """Vale Alimentação"""
  VALE_ALIMENTACAO

  """Vale Refeição"""
  VALE_REFEICAO
}

"""Tipos de chave PIX"""
enum PixKeyType {
  """Chave Aleatória"""
  CHAVE_ALEATORIA

  """CNPJ"""
  CNPJ

  """CPF"""
  CPF

  """E-mail"""
  EMAIL

  """Telefone"""
  TELEFONE
}

type Place {
  banner: String
  categories: [Category!]
  city: String!
  companies: [Company!]
  createdAt: DateTime!
  deletedAt: DateTime
  description: String!
  id: ID!
  isActive: Boolean!
  latitude: Float
  logo: String
  longitude: Float
  name: String!
  neighborhood: String
  organization: Organization!
  organizationId: Float!
  postalCode: String
  segments: [Segment!]
  slug: String!
  state: String!
  subcategories: [Subcategory!]
  updatedAt: DateTime!
  users: [User!]
  uuid: String!
}

input PlaceAggregateFilter {
  and: [PlaceAggregateFilter!]
  banner: StringFieldComparison
  city: StringFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  description: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  latitude: NumberFieldComparison
  logo: StringFieldComparison
  longitude: NumberFieldComparison
  name: StringFieldComparison
  neighborhood: StringFieldComparison
  or: [PlaceAggregateFilter!]
  organizationId: NumberFieldComparison
  postalCode: StringFieldComparison
  slug: StringFieldComparison
  state: StringFieldComparison
  updatedAt: DateFieldComparison
  uuid: StringFieldComparison
}

type PlaceAggregateGroupBy {
  banner: String
  city: String
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: ID
  isActive: Boolean
  latitude: Float
  logo: String
  longitude: Float
  name: String
  neighborhood: String
  organizationId: Float
  postalCode: String
  slug: String
  state: String
  updatedAt: DateTime
  uuid: String
}

type PlaceAggregateResponse {
  avg: PlaceAvgAggregate
  count: PlaceCountAggregate
  groupBy: PlaceAggregateGroupBy
  max: PlaceMaxAggregate
  min: PlaceMinAggregate
  sum: PlaceSumAggregate
}

type PlaceAvgAggregate {
  id: Float
  latitude: Float
  longitude: Float
  organizationId: Float
}

type PlaceConnection {
  """Array of edges."""
  edges: [PlaceEdge!]!

  """Paging information"""
  pageInfo: PageInfo!
}

type PlaceCountAggregate {
  banner: Int
  city: Int
  createdAt: Int
  deletedAt: Int
  description: Int
  id: Int
  isActive: Int
  latitude: Int
  logo: Int
  longitude: Int
  name: Int
  neighborhood: Int
  organizationId: Int
  postalCode: Int
  slug: Int
  state: Int
  updatedAt: Int
  uuid: Int
}

type PlaceEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the Place"""
  node: Place!
}

input PlaceFilter {
  and: [PlaceFilter!]
  banner: StringFieldComparison
  city: StringFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  description: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  latitude: NumberFieldComparison
  logo: StringFieldComparison
  longitude: NumberFieldComparison
  name: StringFieldComparison
  neighborhood: StringFieldComparison
  or: [PlaceFilter!]
  organizationId: NumberFieldComparison
  postalCode: StringFieldComparison
  slug: StringFieldComparison
  state: StringFieldComparison
  updatedAt: DateFieldComparison
  uuid: StringFieldComparison
}

type PlaceMaxAggregate {
  banner: String
  city: String
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: ID
  latitude: Float
  logo: String
  longitude: Float
  name: String
  neighborhood: String
  organizationId: Float
  postalCode: String
  slug: String
  state: String
  updatedAt: DateTime
  uuid: String
}

type PlaceMinAggregate {
  banner: String
  city: String
  createdAt: DateTime
  deletedAt: DateTime
  description: String
  id: ID
  latitude: Float
  logo: String
  longitude: Float
  name: String
  neighborhood: String
  organizationId: Float
  postalCode: String
  slug: String
  state: String
  updatedAt: DateTime
  uuid: String
}

input PlaceSort {
  direction: SortDirection!
  field: PlaceSortFields!
  nulls: SortNulls
}

enum PlaceSortFields {
  banner
  city
  createdAt
  deletedAt
  description
  id
  isActive
  latitude
  logo
  longitude
  name
  neighborhood
  organizationId
  postalCode
  slug
  state
  updatedAt
  uuid
}

type PlaceSumAggregate {
  id: Float
  latitude: Float
  longitude: Float
  organizationId: Float
}

type Query {
  allCompanyBasicInfos: [CompanyBasicInfo!]!
  allCompanyDeliveries: [CompanyDelivery!]!
  allCompanyPayments: [CompanyPayments!]!
  allCompanySchedules: [CompanySchedule!]!
  allCompanySocials: [CompanySocials!]!
  availableCompanyAdmins(placeId: Int!): [User!]!
  availableUsersForCompany(placeId: Int!): [User!]!
  calculateDeliveryFeeByNeighborhood(companyId: Int!, neighborhood: String!, orderValue: Float): String!
  categories: [Category!]!
  categoriesByPlace(placeId: Int!): [Category!]!
  categoriesBySegment(segmentId: Int!): [Category!]!
  category(id: Int!): Category!
  categoryBySlug(placeId: Int!, slug: String!): Category!
  companies: [Company!]!
  companiesByCategory(categoryId: Int!): [Company!]!
  companiesByPaymentMethod(paymentMethod: PaymentMethodType!): [CompanyPayments!]!
  companiesByPlace(placeId: Int!): [Company!]!
  companiesBySegment(segmentId: Int!): [Company!]!
  companiesBySegmentationCriteria(categoryId: Int, placeId: Int, segmentId: Int, subcategoryId: Int): [Company!]!
  companiesBySocialNetwork(networkType: SocialNetworkType!): [CompanySocial!]!
  companiesBySubcategory(subcategoryId: Int!): [Company!]!
  companiesOpenNow(placeId: Int): String!
  companiesThatAcceptPix(placeId: Int): [CompanyPayments!]!
  companiesWithDelivery(placeId: Int): [CompanyDelivery!]!
  companiesWithIncompleteSegmentation: [Company!]!
  companiesWithUserCount(placeId: Int): [Company!]!
  companiesWithoutAdmin(placeId: Int): [Company!]!
  company(id: Int!): Company!
  companyBasicInfo(id: Int!): CompanyBasicInfo!
  companyBasicInfoByCompany(companyId: Int!): CompanyBasicInfo
  companyBasicInfosByPlace(placeId: Int!): [CompanyBasicInfo!]!
  companyBySlug(slug: String!): Company!
  companyDeliveriesByPlace(placeId: Int!): [CompanyDelivery!]!
  companyDelivery(id: Int!): CompanyDelivery!
  companyDeliveryByCompany(companyId: Int!): CompanyDelivery
  companyDetails(id: Int!): Company!
  companyPayments(id: Int!): CompanyPayments!
  companyPaymentsByCompany(companyId: Int!): CompanyPayments
  companyPaymentsByPlace(placeId: Int!): [CompanyPayments!]!
  companySchedule(id: Int!): CompanySchedule!
  companyScheduleByCompany(companyId: Int!): CompanySchedule
  companySchedulesByPlace(placeId: Int!): [CompanySchedule!]!
  companySegmentationHierarchy(id: Int!): String!
  companySocials(id: Int!): CompanySocials!
  companySocialsByCompany(companyId: Int!): CompanySocials
  companySocialsByPlace(placeId: Int!): [CompanySocials!]!
  deliveryStatistics(placeId: Int): String!
  hello: String!
  isCompanyOpenNow(companyId: Int!): String!
  mainOrganization: Organization!
  me: User!
  myCompanies: [Company!]!
  myCompanyBasicInfos: [CompanyBasicInfo!]!
  myCompanyDeliveries: [CompanyDelivery!]!
  myCompanyPayments: [CompanyPayments!]!
  myCompanySchedules: [CompanySchedule!]!
  myCompanySocials: [CompanySocials!]!
  organization(
    """The id of the record to find."""
    id: ID!
  ): Organization
  organizationAggregate(
    """Filter to find records to aggregate on"""
    filter: OrganizationAggregateFilter
  ): [OrganizationAggregateResponse!]!
  organizationBySlug(slug: String!): Organization!
  organizations(
    """Specify to filter the records returned."""
    filter: OrganizationFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [OrganizationSort!]! = []
  ): OrganizationConnection!
  place(
    """The id of the record to find."""
    id: ID!
  ): Place
  placeAggregate(
    """Filter to find records to aggregate on"""
    filter: PlaceAggregateFilter
  ): [PlaceAggregateResponse!]!
  placeBySlug(slug: String!): Place!
  places(
    """Specify to filter the records returned."""
    filter: PlaceFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [PlaceSort!]! = []
  ): PlaceConnection!
  placesByOrganization: [Place!]!
  popularSocials(limit: Int, placeId: Int): [CompanySocial!]!
  scheduleStatistics(placeId: Int): String!
  segment(id: Int!): Segment!
  segmentBySlug(placeId: Int!, slug: String!): Segment!
  segmentationStats(placeId: Int): String!
  segments: [Segment!]!
  segmentsByPlace(placeId: Int!): [Segment!]!
  subcategories: [Subcategory!]!
  subcategoriesByCategory(categoryId: Int!): [Subcategory!]!
  subcategoriesByPlace(placeId: Int!): [Subcategory!]!
  subcategoriesWithCompanyCount(placeId: Int): [Subcategory!]!
  subcategory(id: Int!): Subcategory!
  subcategoryBySlug(placeId: Int!, slug: String!): Subcategory!
  user(
    """The id of the record to find."""
    id: ID!
  ): User
  userAggregate(
    """Filter to find records to aggregate on"""
    filter: UserAggregateFilter
  ): [UserAggregateResponse!]!
  userRoles(userId: Float!): [UserRole!]!
  users(
    """Specify to filter the records returned."""
    filter: UserFilter! = {}

    """Limit or page results."""
    paging: CursorPaging! = {first: 10}

    """Specify to sort results."""
    sorting: [UserSort!]! = []
  ): UserConnection!
  usersByCompany(companyId: Int!): [User!]!
  usersByPlace(placeId: Int!): [User!]!
  validateCompanySegmentation(id: Int!): Boolean!
  verifiedSocials(placeId: Int): [CompanySocial!]!
}

input RequestPasswordResetInput {
  email: String!
}

type RequestPasswordResetResponse {
  message: String!
  success: Boolean!
}

input ResendVerificationInput {
  email: String!
}

input ResetPasswordInput {
  newPassword: String!
  token: String!
}

type ResetPasswordResponse {
  message: String!
  success: Boolean!
}

type Role {
  createdAt: DateTime!
  deletedAt: DateTime
  description: String!
  id: ID!
  isActive: Boolean!
  name: RoleType!
  updatedAt: DateTime!
  userRoles: [UserRole!]
  uuid: String!
}

"""Os tipos de papéis disponíveis no sistema"""
enum RoleType {
  COMPANY_ADMIN
  ORGANIZATION_ADMIN
  PLACE_ADMIN
  PUBLIC_USER
  SUPER_ADMIN
}

"""Tipos de horário"""
enum ScheduleType {
  """Feriado"""
  HOLIDAY

  """Horário regular"""
  REGULAR

  """Horário especial"""
  SPECIAL

  """Fechamento temporário"""
  TEMPORARY_CLOSURE

  """Férias"""
  VACATION
}

type Segment {
  categories: [Category!]
  color: String
  companies: [Company!]
  createdAt: DateTime!
  deletedAt: DateTime
  description: String!
  icon: String
  id: ID!
  isActive: Boolean!
  name: String!
  order: Float!
  place: Place!
  placeId: Float!
  slug: String!
  updatedAt: DateTime!
  uuid: String!
}

input SignUpInput {
  email: String!
  name: String!
  password: String!
  passwordConfirmation: String!
  securityToken: String!
}

type SignUpResponse {
  message: String!
  success: Boolean!
  userId: Float
}

"""Tipos de redes sociais e canais de comunicação"""
enum SocialNetworkType {
  """Blog"""
  BLOG

  """Facebook"""
  FACEBOOK

  """Instagram"""
  INSTAGRAM

  """LinkedIn"""
  LINKEDIN

  """Outras redes sociais"""
  OUTRAS

  """Pinterest"""
  PINTEREST

  """Snapchat"""
  SNAPCHAT

  """Telegram"""
  TELEGRAM

  """TikTok"""
  TIKTOK

  """Twitter (X)"""
  TWITTER

  """Website"""
  WEBSITE

  """WhatsApp"""
  WHATSAPP

  """YouTube"""
  YOUTUBE
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

input StringFieldComparison {
  eq: String
  gt: String
  gte: String
  iLike: String
  in: [String!]
  is: Boolean
  isNot: Boolean
  like: String
  lt: String
  lte: String
  neq: String
  notILike: String
  notIn: [String!]
  notLike: String
}

type Subcategory {
  category: Category!
  categoryId: Float!
  companies: [Company!]
  createdAt: DateTime!
  deletedAt: DateTime
  description: String!
  icon: String
  id: ID!
  isActive: Boolean!
  keywords: String
  name: String!
  order: Float!
  place: Place!
  placeId: Float!
  slug: String!
  updatedAt: DateTime!
  uuid: String!
}

input UpdateCategoryInput {
  color: String
  description: String
  icon: String
  id: Int!
  isActive: Boolean
  keywords: String
  name: String
  order: Float
  placeId: Int
  segmentIds: [Int!]
  slug: String
}

input UpdateCompanyBasicInfoInput {
  address: String
  banner: String
  description: String
  email: String
  id: Int!
  logo: String
  phone: String
  whatsapp: String
}

input UpdateCompanyDeliveryInput {
  acceptsCard: Boolean
  acceptsCash: Boolean
  acceptsPix: Boolean
  availableTypes: [DeliveryType!]
  baseFee: Float
  deliveryInstructions: String
  deliveryPhone: String
  deliveryWhatsApp: String
  deliveryZones: [CreateDeliveryZoneInput!]
  estimatedTimeMinutes: Int
  freeDeliveryMinValue: Float
  id: Int!
  isEnabled: Boolean
  maximumOrderValue: Float
  minimumOrderValue: Float
  pickupInstructions: String
  pickupTimeMinutes: Int
}

input UpdateCompanyInput {
  address: String
  banner: String
  categoryId: Int
  cnpj: String
  description: String
  email: String
  id: Int!
  isActive: Boolean
  latitude: Float
  logo: String
  longitude: Float
  name: String
  openingHours: String
  phone: String
  placeId: Int
  segmentId: Int
  slug: String
  subcategoryId: Int
  users: [CreateCompanyUserInput!]
  website: String
}

input UpdateCompanyPaymentsInput {
  acceptsInstallments: Boolean
  cardInfo: String
  id: Int!
  maxInstallments: Int
  minimumCardAmount: Float
  notes: String
  paymentMethods: [PaymentMethodType!]
  pixDescription: String
  pixKey: String
  pixKeyType: PixKeyType
  voucherInfo: String
}

input UpdateCompanyScheduleInput {
  advanceBookingDays: Int
  allowOnlineScheduling: Boolean
  autoUpdateStatus: Boolean
  closedMessage: String
  hasDeliverySchedule: Boolean
  hasTakeoutSchedule: Boolean
  holidayMessage: String
  id: Int!
  isEnabled: Boolean
  scheduleHours: [CreateScheduleHourInput!]
  scheduleNotes: String
  showNextOpenTime: Boolean
  slotDurationMinutes: Int
  timezone: String
}

input UpdateCompanySocialInput {
  description: String
  displayName: String
  displayOrder: Int
  followersCount: Int
  id: Int!
  isPrimary: Boolean
  isVisible: Boolean
  networkType: SocialNetworkType
  url: String
  username: String
}

input UpdateCompanySocialsInput {
  allowMessages: Boolean
  id: Int!
  isEnabled: Boolean
  primaryContactSocial: String
  showFollowersCount: Boolean
  socialMediaRules: String
  socialMediaStrategy: String
  socialNetworks: [CreateCompanySocialInput!]
}

input UpdateDeliveryZoneInput {
  deliveryFee: Float
  description: String
  estimatedTimeMinutes: Int
  id: Int!
  isEnabled: Boolean
  minimumOrderValue: Float
  name: String
  neighborhoods: String
  priority: Int
}

input UpdateMainOrganizationInput {
  banner: String
  description: String
  isActive: Boolean
  logo: String
  name: String
  slug: String
}

input UpdateManyOrganizationsInput {
  """Filter used to find fields to update"""
  filter: OrganizationUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateOrganizationInput!
}

type UpdateManyResponse {
  """The number of records updated."""
  updatedCount: Int!
}

input UpdateOneOrganizationInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateOrganizationInput!
}

input UpdateOrganizationInput {
  banner: String
  description: String
  id: Int!
  isActive: Boolean
  logo: String
  name: String
  slug: String
}

input UpdatePlaceInput {
  banner: String
  city: String
  description: String
  id: Int!
  isActive: Boolean
  latitude: Float
  logo: String
  longitude: Float
  name: String
  neighborhood: String
  postalCode: String
  slug: String
  state: String
}

input UpdateScheduleHourInput {
  breakEndTime: String
  breakStartTime: String
  closeTime: String
  dayOfWeek: DayOfWeek
  id: Int!
  is24Hours: Boolean
  isClosed: Boolean
  notes: String
  openTime: String
  priority: Int
  scheduleType: ScheduleType
  specificDate: String
  validFrom: String
  validUntil: String
}

input UpdateSegmentInput {
  categoryIds: [Int!]
  color: String
  description: String
  icon: String
  id: Int!
  isActive: Boolean
  name: String
  order: Float
  placeId: Int
  slug: String
}

input UpdateSubcategoryInput {
  categoryId: Int
  description: String
  icon: String
  id: Int!
  isActive: Boolean
  keywords: String
  name: String
  order: Float
  placeId: Int
  slug: String
}

input UpdateUserInput {
  avatar: String
  companyId: Int
  id: Int!
  isActive: Boolean
  name: String
  organizationId: Int
  password: String
  phone: String
  placeId: Int
  roleIds: [Int!]
}

type User {
  avatar: String
  company: Company
  companyId: Float
  createdAt: DateTime!
  deletedAt: DateTime
  email: String!
  id: ID!
  isActive: Boolean!
  isVerified: Boolean!
  name: String!
  organization: Organization
  organizationId: Float
  phone: String
  place: Place
  placeId: Float
  updatedAt: DateTime!
  userRoles: [UserRole!]
  uuid: String!
}

input UserAggregateFilter {
  and: [UserAggregateFilter!]
  avatar: StringFieldComparison
  companyId: NumberFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  email: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  isVerified: BooleanFieldComparison
  name: StringFieldComparison
  or: [UserAggregateFilter!]
  organizationId: NumberFieldComparison
  phone: StringFieldComparison
  placeId: NumberFieldComparison
  updatedAt: DateFieldComparison
  uuid: StringFieldComparison
}

type UserAggregateGroupBy {
  avatar: String
  companyId: Float
  createdAt: DateTime
  deletedAt: DateTime
  email: String
  id: ID
  isActive: Boolean
  isVerified: Boolean
  name: String
  organizationId: Float
  phone: String
  placeId: Float
  updatedAt: DateTime
  uuid: String
}

type UserAggregateResponse {
  avg: UserAvgAggregate
  count: UserCountAggregate
  groupBy: UserAggregateGroupBy
  max: UserMaxAggregate
  min: UserMinAggregate
  sum: UserSumAggregate
}

type UserAvgAggregate {
  companyId: Float
  id: Float
  organizationId: Float
  placeId: Float
}

type UserConnection {
  """Array of edges."""
  edges: [UserEdge!]!

  """Paging information"""
  pageInfo: PageInfo!
}

type UserCountAggregate {
  avatar: Int
  companyId: Int
  createdAt: Int
  deletedAt: Int
  email: Int
  id: Int
  isActive: Int
  isVerified: Int
  name: Int
  organizationId: Int
  phone: Int
  placeId: Int
  updatedAt: Int
  uuid: Int
}

type UserDeleteResponse {
  avatar: String
  company: Company
  companyId: Float
  createdAt: DateTime
  deletedAt: DateTime
  email: String
  id: ID
  isActive: Boolean
  isVerified: Boolean
  name: String
  organization: Organization
  organizationId: Float
  phone: String
  place: Place
  placeId: Float
  updatedAt: DateTime
  userRoles: [UserRole!]
  uuid: String
}

type UserEdge {
  """Cursor for this node."""
  cursor: ConnectionCursor!

  """The node containing the User"""
  node: User!
}

input UserFilter {
  and: [UserFilter!]
  avatar: StringFieldComparison
  companyId: NumberFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  email: StringFieldComparison
  id: IDFilterComparison
  isActive: BooleanFieldComparison
  isVerified: BooleanFieldComparison
  name: StringFieldComparison
  or: [UserFilter!]
  organizationId: NumberFieldComparison
  phone: StringFieldComparison
  placeId: NumberFieldComparison
  updatedAt: DateFieldComparison
  uuid: StringFieldComparison
}

type UserMaxAggregate {
  avatar: String
  companyId: Float
  createdAt: DateTime
  deletedAt: DateTime
  email: String
  id: ID
  name: String
  organizationId: Float
  phone: String
  placeId: Float
  updatedAt: DateTime
  uuid: String
}

type UserMinAggregate {
  avatar: String
  companyId: Float
  createdAt: DateTime
  deletedAt: DateTime
  email: String
  id: ID
  name: String
  organizationId: Float
  phone: String
  placeId: Float
  updatedAt: DateTime
  uuid: String
}

type UserRole {
  createdAt: DateTime!
  deletedAt: DateTime
  id: ID!
  isActive: Boolean!
  role: Role!
  roleId: Float!
  updatedAt: DateTime!
  user: User!
  userId: Float!
  uuid: String!
}

input UserSort {
  direction: SortDirection!
  field: UserSortFields!
  nulls: SortNulls
}

enum UserSortFields {
  avatar
  companyId
  createdAt
  deletedAt
  email
  id
  isActive
  isVerified
  name
  organizationId
  phone
  placeId
  updatedAt
  uuid
}

type UserSumAggregate {
  companyId: Float
  id: Float
  organizationId: Float
  placeId: Float
}

input VerifyEmailInput {
  token: String!
}

type VerifyEmailResponse {
  message: String!
  success: Boolean!
}